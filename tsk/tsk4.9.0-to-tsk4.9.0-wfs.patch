diff --git a/.gitignore b/.gitignore
index 3f5987de..d5f3f3cb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -184,3 +184,14 @@ unit_tests/base/test_base
 #Test data folder
 
 tests/data
+
+# GBAT files for WFS0.4/5
+add-vars-tobuild.bat
+copy-to-iped-3.13.4.bat
+copy-to-iped-3.16.3.bat
+gbat-changes.txt
+remove-vars-tobuild.bat
+tools/pooltools/pstat
+tsk48.cbp
+tsk48.layout
+tsk48.layout
\ No newline at end of file
diff --git a/README.md b/README.md
index ff66ccf0..0c163adb 100644
--- a/README.md
+++ b/README.md
@@ -1,185 +1,12 @@
-[![Build Status](https://travis-ci.org/sleuthkit/sleuthkit.svg?branch=develop)](https://travis-ci.org/sleuthkit/sleuthkit)
+# [The Sleuth Kit with WFS0.4/5 support](http://www.sleuthkit.org/sleuthkit)
 
-[![Build status](https://ci.appveyor.com/api/projects/status/8f7ljj8s2lh5sqfv?svg=true)](https://ci.appveyor.com/project/bcarrier/sleuthkit)
+This is a fork to implement WFS0.4/5 support in The Sleuth Kit. WFS is a file system popular in chinese DVRs and we donÂ´t know any tool public available to extract videos from this file system.
 
-# [The Sleuth Kit](http://www.sleuthkit.org/sleuthkit)
+This software should be used with care; I and a partner have decoded the filesystem from scratch and, of course, error are problable. In spite, we have succefully tested this implementation in a dozen of images acquired in several contexts. 
 
-## INTRODUCTION
-The Sleuth Kit is an open source forensic toolkit for analyzing
-Microsoft and UNIX file systems and disks.  The Sleuth Kit enables
-investigators to identify and recover evidence from images acquired
-during incident response or from live systems.  The Sleuth Kit is
-open source, which allows investigators to verify the actions of
-the tool or customize it to specific needs.
+We have also implemented in Python a tool capable of extract videos. In some days, I will public that program. It is more convenient if you want just export videos using a GUI.
 
-The Sleuth Kit uses code from the file system analysis tools of
-The Coroner's Toolkit (TCT) by Wietse Venema and Dan Farmer.  The
-TCT code was modified for platform independence.  In addition,
-support was added for the NTFS (see [wiki/ntfs](http://wiki.sleuthkit.org/index.php?title=FAT_Implementation_Notes)) 
-and FAT (see [wiki/fat](http://wiki.sleuthkit.org/index.php?title=NTFS_Implementation_Notes)) file systems.  Previously, The Sleuth Kit was
-called The @stake Sleuth Kit (TASK).  The Sleuth Kit is now independent
-of any commercial or academic organizations.
+Galileu Batista
+Unaldo Brito (this guy have made a great work in decoding WFS).
 
-It is recommended that these command line tools can be used with
-the Autopsy Forensic Browser.  Autopsy, (http://www.sleuthkit.org/autopsy),
-is a graphical interface to the tools of The Sleuth Kit and automates
-many of the procedures and provides features such as image searching
-and MD5 image integrity checks.
-
-As with any investigation tool, any results found with The Sleuth
-Kit should be be recreated with a second tool to verify the data.
-
-## OVERVIEW
-The Sleuth Kit allows one to analyze a disk or file system image
-created by 'dd', or a similar application that creates a raw image.
-These tools are low-level and each performs a single task.  When
-used together, they can perform a full analysis.  For a more detailed
-description of these tools, refer to [wiki/filesystem](http://wiki.sleuthkit.org/index.php?title=TSK_Tool_Overview). 
-The tools are briefly described in a file system layered approach.  Each
-tool name begins with a letter that is assigned to the layer.  
-
-### File System Layer:
-A disk contains one or more partitions (or slices).  Each of these
-partitions contain a file system.  Examples of file systems include
-the Berkeley Fast File System (FFS), Extended 2 File System (EXT2FS),
-File Allocation Table (FAT), and New Technologies File System (NTFS).
-
-The fsstat tool displays file system details in an ASCII format.
-Examples of data in this display include volume name, last mounting
-time, and the details about each "group" in UNIX file systems.
-
-### Content Layer (block):
-The content layer of a file system contains the actual file content,
-or data.  Data is stored in large chunks, with names such as blocks,
-fragments, and clusters.  All tools in this layer begin with the letters
-'blk'.  
-
-The blkcat tool can be used to display the contents of a specific unit of
-the file system (similar to what 'dd' can do with a few arguments).
-The unit size is file system dependent.  The 'blkls' tool displays the
-contents of all unallocated units of a file system, resulting in a
-stream of bytes of deleted content.  The output can be searched for
-deleted file content.  The 'blkcalc' program allows one to identify the
-unit location in the original image of a unit in the 'blkls' generated
-image.
-
-A new feature of The Sleuth Kit from TCT is the '-l' argument to
-'blkls' (or 'unrm' in TCT).  This argument lists the details for data
-units, similar to the 'ils' command.  The 'blkstat' tool displays
-the statistics of a specific data unit (including allocation status
-and group number).
-
-### Metadata Layer (inode):
-The metadata layer describes a file or directory.  This layer contains
-descriptive data such as dates and size as well as the addresses of the
-data units.  This layer describes the file in terms that the computer
-can process efficiently.   The structures that the data is stored in
-have names such as inode and directory entry.  All tools in this layer
-begin with an 'i'.  
-
-The 'ils' program lists some values of the metadata structures.
-By default, it will only list the unallocated ones.  The 'istat'
-displays metadata information in an ASCII format about a specific
-structure.  New to The Sleuth Kit is that 'istat' will display the
-destination of symbolic links.  The 'icat' function displays the
-contents of the data units allocated to the metadata structure
-(similar to the UNIX cat(1) command).  The 'ifind' tool will identify
-which metadata structure has allocated a given content unit or
-file name.
-
-Refer to the [ntfs wiki](http://wiki.sleuthkit.org/index.php?title=NTFS_Implementation_Notes) 
-for information on addressing metadata attributes in NTFS.
-
-### Human Interface Layer (file):
-The human interface layer allows one to interact with files in a
-manner that is more convenient than directly with the metadata
-layer.  In some operating systems there are separate structures for
-the metadata and human interface layers while others combine them.
-All tools in this layer begin with the letter 'f'.  
-
-The 'fls' program lists file and directory names.  This tool will
-display the names of deleted files as well.  The 'ffind' program will
-identify the name of the file that has allocated a given metadata
-structure.  With some file systems, deleted files will be identified.
-
-#### Time Line Generation
-Time lines are useful to quickly get a picture of file activity.
-Using The Sleuth Kit a time line of file MAC times can be easily
-made.  The mactime (TCT) program takes as input the 'body' file
-that was generated by fls and ils.  To get data on allocated and
-unallocated file names, use 'fls -rm dir' and for unallocated inodes
-use 'ils -m'.  Note that the behavior of these tools are different
-than in TCT.  For more information, refer to [wiki/mactime](http://wiki.sleuthkit.org/index.php?title=Mactime).
-
-
-#### Hash Databases
-Hash databases are used to quickly identify if a file is known.  The
-MD5 or SHA-1 hash of a file is taken and a database is used to identify
-if it has been seen before.  This allows identification to occur even
-if a file has been renamed.
-
-The Sleuth Kit includes the 'md5' and 'sha1' tools to generate
-hashes of files and other data.
-
-Also included is the 'hfind' tool.  The 'hfind' tool allows one to create
-an index of a hash database and perform quick lookups using a binary
-search algorithm.  The 'hfind' tool can perform lookups on the NIST
-National Software Reference Library (NSRL) (www.nsrl.nist.gov) and
-files created from the 'md5' or 'md5sum' command.   Refer to the 
-[wiki/hfind](http://wiki.sleuthkit.org/index.php?title=Hfind) file for more details.  
-
-#### File Type Categories
-Different types of files typically have different internal structure.
-The 'file' command comes with most versions of UNIX and a copy is
-also distributed with The Sleuth Kit.  This is used to identify
-the type of file or other data regardless of its name and extension.
-It can even be used on a given data unit to help identify what file
-used that unit for storage.  Note that the 'file' command typically
-uses data in the first bytes of a file so it may not be able to
-identify a file type based on the  middle blocks or clusters.
-
-The 'sorter' program in The Sleuth Kit will use other Sleuth Kit
-tools to sort the files in a file system image into categories.
-The categories are based on rule sets in configuration files.  The
-'sorter' tool will also use hash databases to flag known bad files
-and ignore known good files.  Refer to the [wiki/sorter](http://wiki.sleuthkit.org/index.php?title=Sorter)
-file for more details.
-
-
-## LICENSE
-There are a variety of licenses used in TSK based on where they
-were first developed.  The licenses are located in the [licenses
-directory](https://github.com/sleuthkit/sleuthkit/tree/develop/licenses).
-
-- The file system tools (in the
-[tools/fstools](https://github.com/sleuthkit/sleuthkit/tree/develop/tools/fstools)
-directory) are released under the IBM open source license and Common
-Public License.
-- srch_strings and fiwalk are released under the GNU Public License
-- Other tools in the tools directory are Common Public License
-- The modifications to 'mactime' from the original 'mactime' in TCT
-and 'mac-daddy' are released under the Common Public License.
-
-The library uses utilities that were released under MIT and BSD 3-clause. 
-
-
-## INSTALL
-For installation instructions, refer to the INSTALL.txt document.
-
-## OTHER DOCS
-The [wiki](http://wiki.sleuthkit.org/index.php?title=Main_Page) contains documents that 
-describe the provided tools in more detail.  The Sleuth Kit Informer is a newsletter that contains
-new documentation and articles.
-
-> www.sleuthkit.org/informer/
-
-## MAILING LIST
-Mailing lists exist on SourceForge, for both users and a low-volume
-announcements list.
-
-> http://sourceforge.net/mail/?group_id=55685
-
-Brian Carrier
-
-carrier at sleuthkit dot org
- 
+gbatmobile at -gmail *com
diff --git a/bindings/java/src/org/sleuthkit/datamodel/Bundle.properties b/bindings/java/src/org/sleuthkit/datamodel/Bundle.properties
index c3728bb0..383c2b62 100644
--- a/bindings/java/src/org/sleuthkit/datamodel/Bundle.properties
+++ b/bindings/java/src/org/sleuthkit/datamodel/Bundle.properties
@@ -241,6 +241,7 @@ TskData.tskFsTypeEnum.ISO9660autoDetect=ISO9660 (Auto Detection)
 TskData.tskFsTypeEnum.HFSautoDetect=HFS (Auto Detection)
 TskData.tskFsTypeEnum.YAFFS2autoDetect=YAFFS2 (Auto Detection)
 TskData.tskFsTypeEnum.APFSautoDetect=APFS (Auto Detection)
+TskData.tskFsTypeEnum.WFSautoDetect=WFS (WFS Detection)
 TskData.tskFsTypeEnum.unsupported=Unsupported File System
 TskData.tskImgTypeEnum.autoDetect=Auto Detect
 TskData.tskImgTypeEnum.rawSingle=Raw Single
diff --git a/bindings/java/src/org/sleuthkit/datamodel/TskData.java b/bindings/java/src/org/sleuthkit/datamodel/TskData.java
index 6ff21a0a..d10efa80 100644
--- a/bindings/java/src/org/sleuthkit/datamodel/TskData.java
+++ b/bindings/java/src/org/sleuthkit/datamodel/TskData.java
@@ -462,6 +462,9 @@ public static short toInt(Set<TSK_FS_META_MODE_ENUM> modes) {
 		TSK_FS_TYPE_YAFFS2_DETECT(0x00004000, bundle.getString("TskData.tskFsTypeEnum.YAFFS2autoDetect")), ///< YAFFS2 auto detection
 		TSK_FS_TYPE_APFS(0x00010000, "APFS"), ///< APFS file system
 		TSK_FS_TYPE_APFS_DETECT(0x00010000, bundle.getString("TskData.tskFsTypeEnum.APFSautoDetect")), ///< APFS auto detection
+		TSK_FS_TYPE_WFS_04(0x00020000, "WFS0.4"), ///< WFS0.4 file system
+		TSK_FS_TYPE_WFS_05(0x00040000, "WFS0.5"), ///< WFS0.5 file system
+		TSK_FS_TYPE_WFS_DETECT(0x00060000, bundle.getString("TskData.tskFsTypeEnum.WFSautoDetect")), ///< WFS auto detection		
 		TSK_FS_TYPE_UNSUPP(0xffffffff, bundle.getString("TskData.tskFsTypeEnum.unsupported"));        ///< Unsupported file system
 
 		private int value;
diff --git a/tsk/fs/Makefile.am b/tsk/fs/Makefile.am
index c3723f8b..4d3a51b3 100644
--- a/tsk/fs/Makefile.am
+++ b/tsk/fs/Makefile.am
@@ -8,6 +8,7 @@ libtskfs_la_SOURCES  = tsk_fs_i.h fs_inode.c fs_io.c fs_block.c fs_open.c \
     fs_parse.c fs_file.c \
     unix_misc.c nofs_misc.c \
     ffs.c ffs_dent.c ext2fs.c ext2fs_dent.c ext2fs_journal.c \
+    wfsfs.c wfsfs_dent.c \
     fatfs.c fatfs_meta.c fatfs_dent.cpp \
     fatxxfs.c fatxxfs_meta.c fatxxfs_dent.c \
     exfatfs.c exfatfs_meta.c exfatfs_dent.c \
diff --git a/tsk/fs/fs_open.c b/tsk/fs/fs_open.c
index 3a564f0d..342abf16 100755
--- a/tsk/fs/fs_open.c
+++ b/tsk/fs/fs_open.c
@@ -137,7 +137,10 @@ tsk_fs_open_img_decrypt(TSK_IMG_INFO * a_img_info, TSK_OFF_T a_offset,
         { "FAT",      fatfs_open,   TSK_FS_TYPE_FAT_DETECT     },
         { "EXT2/3/4", ext2fs_open,  TSK_FS_TYPE_EXT_DETECT     },
         { "UFS",      ffs_open,     TSK_FS_TYPE_FFS_DETECT     },
-        { "YAFFS2",   yaffs2_open,  TSK_FS_TYPE_YAFFS2_DETECT  },
+//        { "YAFFS2",   yaffs2_open,  TSK_FS_TYPE_YAFFS2_DETECT  },
+#if TSK_USE_WFS
+        { "WFS",      wfsfs_open,     TSK_FS_TYPE_WFS_DETECT   },
+#endif
 #if TSK_USE_HFS
         { "HFS",      hfs_open,     TSK_FS_TYPE_HFS_DETECT     },
 #endif
@@ -228,6 +231,10 @@ tsk_fs_open_img_decrypt(TSK_IMG_INFO * a_img_info, TSK_OFF_T a_offset,
     else if (TSK_FS_TYPE_ISAPFS(a_ftype)) {
         return apfs_open(a_img_info, a_offset, a_ftype, a_pass);
     }
+    else if (TSK_FS_TYPE_ISWFS(a_ftype)) {
+        return wfsfs_open(a_img_info, a_offset, a_ftype, 0);
+    }
+
     tsk_error_reset();
     tsk_error_set_errno(TSK_ERR_FS_UNSUPTYPE);
     tsk_error_set_errstr("%X", (int) a_ftype);
diff --git a/tsk/fs/fs_types.c b/tsk/fs/fs_types.c
index eef6b4fa..7ea338d0 100644
--- a/tsk/fs/fs_types.c
+++ b/tsk/fs/fs_types.c
@@ -42,7 +42,10 @@ static FS_TYPES fs_type_table[] = {
     {"ntfs", TSK_FS_TYPE_NTFS, "NTFS"}, // NTFS == NTFS_DETECT 
     {"fat", TSK_FS_TYPE_FAT_DETECT, "FAT (Auto Detection)"},
     {"ext", TSK_FS_TYPE_EXT_DETECT, "ExtX (Auto Detection)"},
-    {"iso9660", TSK_FS_TYPE_ISO9660, "ISO9660 CD"}, // ISO9660 == DETECT
+    {"iso9660", TSK_FS_TYPE_ISO9660_DETECT, "ISO9660 CD"},
+#if TSK_USE_WFS
+    {"wfs", TSK_FS_TYPE_WFS_DETECT, "WFS0.4/5"},
+#endif
 #if TSK_USE_HFS
     {"hfs", TSK_FS_TYPE_HFS_DETECT, "HFS+ (Auto Detection)"},
 #endif
diff --git a/tsk/fs/tsk_fs.h b/tsk/fs/tsk_fs.h
index 21585845..49742a3f 100644
--- a/tsk/fs/tsk_fs.h
+++ b/tsk/fs/tsk_fs.h
@@ -820,6 +820,9 @@ extern "C" {
         TSK_FS_TYPE_HFS_LEGACY= 0x00008000,   ///< HFS file system
         TSK_FS_TYPE_APFS = 0x00010000, ///< APFS file system
         TSK_FS_TYPE_APFS_DETECT = 0x00010000, ///< APFS auto detection
+        TSK_FS_TYPE_WFS_04 = 0x00020000, ///< WFS 0.4
+        TSK_FS_TYPE_WFS_05 = 0x00040000, ///< WFS 0.5
+        TSK_FS_TYPE_WFS_DETECT = 0x00060000, ///< WFS auto detection
         TSK_FS_TYPE_UNSUPP = 0xffffffff,        ///< Unsupported file system
     };
     /* NOTE: Update bindings/java/src/org/sleuthkit/datamodel/TskData.java
@@ -854,6 +857,14 @@ extern "C" {
 #define TSK_FS_TYPE_ISEXT(ftype) \
     (((ftype) & TSK_FS_TYPE_EXT_DETECT)?1:0)
 
+    /**
+    * \ingroup fslib
+    * Macro that takes a file system type and returns 1 if the type
+    * is for a ExtX file system. */
+#define TSK_FS_TYPE_ISWFS(ftype) \
+    (((ftype) & TSK_FS_TYPE_WFS_DETECT)?1:0)
+
+
     /**
     * \ingroup fslib
     * Macro that takes a file system type and returns 1 if the type
diff --git a/tsk/fs/tsk_fs_i.h b/tsk/fs/tsk_fs_i.h
index 0340e82a..24a71ff5 100644
--- a/tsk/fs/tsk_fs_i.h
+++ b/tsk/fs/tsk_fs_i.h
@@ -57,6 +57,12 @@ extern "C" {
 #define TSK_USE_HFS 1
 #endif                          /*  */
 
+// set to 1 to open WFS0.4/5 file systems -- which is not fully tested
+#ifndef TSK_USE_WFS
+#define TSK_USE_WFS 1
+#endif                          /*  */
+
+
 #ifndef NBBY
 #define NBBY 8
 #endif                          /*  */
@@ -198,6 +204,8 @@ extern "C" {
         TSK_FS_TYPE_ENUM, uint8_t);
     extern TSK_FS_INFO *yaffs2_open(TSK_IMG_INFO *, TSK_OFF_T,
         TSK_FS_TYPE_ENUM, uint8_t);
+    extern TSK_FS_INFO *wfsfs_open(TSK_IMG_INFO *, TSK_OFF_T,
+        TSK_FS_TYPE_ENUM, uint8_t);
 
     /* Specific pool file system routines */
     extern TSK_FS_INFO *apfs_open_auto_detect(TSK_IMG_INFO*, TSK_OFF_T,
diff --git a/tsk/fs/tsk_wfsfs.h b/tsk/fs/tsk_wfsfs.h
new file mode 100644
index 00000000..7b2eee90
--- /dev/null
+++ b/tsk/fs/tsk_wfsfs.h
@@ -0,0 +1,176 @@
+/*
+** The Sleuth Kit
+**
+** Brian Carrier [carrier <at> sleuthkit [dot] org]
+** Copyright (c) 2003-2011 Brian Carrier.  All rights reserved
+**
+** TASK
+** Copyright (c) 2002 Brian Carrier, @stake Inc.  All rights reserved
+**
+** This software is distributed under the Common Public License 1.0
+*/
+
+/*
+ * Contains the structures and function APIs for WFS0.4/5 file system support.
+ */
+
+#ifndef _TSK_WFSFS_H
+#define _TSK_WFSFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+** Constants
+*/
+#define WFSFS_HEADER_BLK   0     /* Block 0  contais the Header */
+#define WFSFS_SEC_SIZE     512   /* Sector size */
+#define WFSFS_HEADOFS      (WFSFS_HEADER_BLK * WFSFS_SEC_SIZE)
+
+#define WFSFS_SB_SECTOR     24    /* Block 24 contains the superblock (24 * 512 = 0x3000) */
+#define WFSFS_SBOFF        (WFSFS_SB_SECTOR * WFSFS_SEC_SIZE)
+
+#define SET_BIT(buf, bit_pos) buf[(bit_pos) / 8] |= 1 << ((bit_pos) % 8)
+#define UNSET_BIT(buf, bit_pos) buf[(bit_pos) / 8] &= ~(1 << ((bit_pos) % 8))
+
+#define WFSFS_MAGIC_WFS04       "WFS0.4"
+#define WFSFS_MAGIC_WFS05       "WFS0.5"
+#define WFSFS_HEADER_FOOT       "XM"
+
+#define WFSFS_MAXNAMLEN         35  /* strlen("Vid-YYYYMMDD-HHMMSS-HHMMSS.CCC.h264") */
+#define WFSFS_INODE_SIZE        32
+
+#define WFSFS_FILE_CONTENT_LEN sizeof(TSK_DADDR_T)      // we will store the starting cluster
+
+#define WFSFS_FRAG_2_BLOCK(sb, f)	\
+	(TSK_DADDR_T)(tsk_getu32(TSK_LIT_ENDIAN,  sb->s_first_data_block) + \
+                       f * tsk_getu32(TSK_LIT_ENDIAN, sb->s_blocks_per_frag))
+
+#define WFSFS_INODE_TABLE_SIZE(wfsfs) \
+    ((tsk_getu32(wfsfs->fs_info.endian, wfsfs->sb.s_total_indexes) * WFSFS_INODE_SIZE - 1) \
+           / wfsfs->fs_info.block_size + 1)
+
+#define WFSFS_CAM_NUM(cam_id) ((cam_id + 2) / 4)
+
+    time_t wfsfs_mktime(const uint8_t* wfs_time);
+
+    typedef struct {
+        char h_fs_magic[6];
+        char h_filler[504];
+        char h_footer[2];
+    } wfsfs_header;
+
+/*
+** Super Block
+*/
+    typedef struct {
+        uint8_t s_filler1[16];
+
+        uint8_t s_time_last_modification[4];
+                                            // off:16 - timestamp of the last video stored 
+                                            // in disk.
+                                            // In general this is one the fragment neaerst
+                                            //   format: YYYYYYMMMMDDDDDHHHHHmmmmmmSSSSSS
+
+        uint8_t s_time_newest_modification[4];
+                                            // off:20 -timestamp of the first fragment stored 
+                                            // in disk.
+                                            // In general this fragment is stored just before
+                                            // the fragments reserved to be overwritten in
+                                            // following operation
+                                            //    format: YYYYYYMMMMDDDDDHHHHHmmmmmmSSSSSS
+
+        uint8_t s_index_last_frag[4];       // off:24 - number of the last (newest) fragment 
+                                            // in a video.
+        uint8_t s_index_first_frag[4];      // off:28 - number of the first fragment (oldest) 
+                                            // in a video.
+
+        uint8_t s_last_index_valid[4];      // off:32 - last index/fragment in disk
+
+        uint8_t s_time_oldest_creation[4];  // off:36
+                                            // timestamp of the first video (oldest) stored in disk.
+                                            // In general, the first video right after ones
+                                            // reserved to be overwritten in following operation.
+                                            //    format: YYYYYYMMMMDDDDDHHHHHmmmmmmSSSSSS
+
+        uint8_t s_time_first_creation[4];   // off:40
+                                            // timestamp of the first fragment in disk
+                                            // in general, the first fragment after
+                                            // the reserved ones in the start of disk.
+                                            //    format: YYYYYYMMMMDDDDDHHHHHmmmmmmSSSSSS
+
+        uint8_t s_block_size[4];            // off:44 - block size in bytes 
+                                            //     (tipycally: 512 - one sector)
+        uint8_t s_blocks_per_frag[4];       // off:48 - blocks per fragment
+        uint8_t s_filler2[4];               // off:52 - Unknown - values identified: 0x00000000
+        uint8_t s_num_reserv_frags[4];      // off:56 - Number of indexes/fragments in the 
+                                            //      beginning of fs not used
+        uint8_t s_filler3[4];               // off:60 - Unknown - values identified: 0x00003100
+
+        uint8_t s_filler4[4];               // off:64 - Unknown - values identified: 0x00000018
+        uint8_t s_first_index_block[4];     // off:68 - first disk block in index area
+        uint8_t s_first_data_block[4];      // off:72 - first disk block in data area
+        uint8_t s_total_indexes[4];         // off:76 - Number of indexes (and fragments) in 
+                                            //      file system
+        uint8_t s_filler5[432];             // off:80
+    } WFSFS_SB;
+
+/*
+ * Inode
+ */
+    typedef struct {
+        uint8_t i_filler1[1],        /* off:0   */
+                i_type_desc[1],      /* off:1   */
+                i_numb_frag[2],      /* off:2 - */
+                                     //    Extra fragments in this file - inode (0x02 or 0x03).
+                                     //    Fragment number for continuation (0x01).
+                i_prev_frag[4],      /* off:4   */
+                i_next_frag[4],      /* off:8   */
+                i_time_start[4],     /* off:12  */
+                i_time_end[4],       /* off:16  */
+                i_filler2[2],        /* off:20  */
+                i_blks_in_last[2],   /* off:22  */
+                i_main_frag[4],      /* off:24  */
+                i_filler3[2],        /* off:28  */
+                i_frag_order[1],     /* off:30  */
+                i_camera[1];         /* off:31  */
+    } WFSFS_INODE;
+
+/*
+ * directory entries
+ */
+    typedef struct {
+        uint8_t d_type[1];                   /* 1 - datedir;  2 - camdir; 3 - file */
+        union {
+            uint8_t             d_inode[4];
+            struct WFSFS_DENTRY *next_dent;
+        };
+        uint8_t d_name_len[2];
+        char    d_name[WFSFS_MAXNAMLEN];
+    } WFSFS_DENTRY;
+
+    /*
+     * Structure of an WFS file system handle.
+     */
+    typedef struct {
+        TSK_FS_INFO   fs_info;      /* super class */
+        WFSFS_SB      sb;           /* super block */
+        TSK_FS_META   *root_inode;  /* root inode (virtual) */
+    } WFSFS_INFO;
+
+
+    TSK_RETVAL_ENUM
+        wfsfs_dir_open_meta(TSK_FS_INFO * a_fs, TSK_FS_DIR ** a_fs_dir,
+            TSK_INUM_T a_addr);
+    void
+        wfs_debug_print_buf(const char* msg,
+            const uint8_t* buf, int len);
+
+        TSK_RETVAL_ENUM
+        wfsfs_gen_root(WFSFS_INFO* wfsfs, TSK_INUM_T i_num);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/tsk/fs/wfsfs.c b/tsk/fs/wfsfs.c
new file mode 100644
index 00000000..e4bc9fa6
--- /dev/null
+++ b/tsk/fs/wfsfs.c
@@ -0,0 +1,1037 @@
+/*
+** The Sleuth Kit
+**
+** Brian Carrier [carrier <at> sleuthkit [dot] org]
+** Copyright (c) 2006-2011 Brian Carrier, Basis Technology.  All Rights reserved
+** Copyright (c) 2003-2005 Brian Carrier.  All rights reserved
+**
+** TASK
+** Copyright (c) 2002-2003 Brian Carrier, @stake Inc.  All rights reserved
+**
+** Copyright (c) 1997,1998,1999, International Business Machines
+** Corporation and others. All Rights Reserved.
+*/
+
+/**
+ *\file wfsfs.c
+ * Contains the internal TSK WFS0.4/5 file system functions.
+ */
+
+/* WFS Decoder
+ * LICENSE
+ *	This software is distributed under GNU Public License.
+ * AUTHOR(S)
+ *	Galileu Batista (gbat2k ... gbatmobile)
+ *	Brazilian Federal Police & Federal Institute of Technonoly in RN
+ *	Natal, RN, BRAZIL
+ *
+ * Copyright (c) 2020 Galileu Batista.  All rights reserved
+ *
+ --*/
+
+#include "tsk_fs_i.h"
+#include "tsk_wfsfs.h"
+#include "tsk/base/crc.h"
+#include <stddef.h>
+#include <time.h>
+
+#define WFS_DBG 1
+#ifdef WFS_DBG
+
+void
+wfs_debug_print_buf(const char *msg, const uint8_t *buf, int len)
+{
+    tsk_fprintf(stderr, msg);
+    int i = 0;
+    for (i = 0; i < len; i++) {
+        if (i % 8 == 0)
+        tsk_fprintf(stderr, "%08X:\t", i);
+        tsk_fprintf(stderr, "0x%02X ", buf[i]);
+        if ((i + 1) % 8 == 0)
+            tsk_fprintf(stderr, "\n");
+    }
+    tsk_fprintf(stderr, "\n");
+}
+#endif
+
+time_t
+wfsfs_mktime(const uint8_t *wfs_time) {
+    struct tm tm;
+    tm.tm_year = (wfs_time[3] >> 2) + 100;
+    tm.tm_mon  = ((wfs_time[3] & 0x03) << 2) + (wfs_time[2] >> 6) - 1;
+    tm.tm_mday = (wfs_time[2] >> 1) & 0x1F;
+    tm.tm_hour = ((wfs_time[2] << 4) + (wfs_time[1] >> 4)) & 0x1F;
+    tm.tm_min  = ((wfs_time[1] << 2) + (wfs_time[0] >> 6)) & 0x3F;
+    tm.tm_sec  = wfs_time[0] & 0x3F;
+    return mktime(&tm);
+
+    wfs_debug_print_buf("timestamp: \n", wfs_time, 4);
+}
+
+static uint64_t
+wfsfs_get_file_size (WFSFS_INFO *wfsfs, const WFSFS_INODE * dino_buf)
+{
+    uint64_t size = 0;
+
+    int   nfrag = tsk_getu32(TSK_LIT_ENDIAN, dino_buf->i_numb_frag);
+    int   blk_per_frag = tsk_getu32(TSK_LIT_ENDIAN,
+                        wfsfs->sb.s_blocks_per_frag);
+    size = nfrag * blk_per_frag;
+    size += tsk_getu16(TSK_LIT_ENDIAN, dino_buf->i_blks_in_last);
+    size *= wfsfs->fs_info.block_size;
+    return size;
+}
+
+static uint8_t
+wfs_dump_inode(WFSFS_INFO * wfsfs, TSK_INUM_T dino_inum,
+        WFSFS_INODE *dino_buf) {
+
+    int to_load = dino_buf == NULL;
+    TSK_OFF_T    addr;
+    ssize_t      cnt;
+    WFSFS_SB    *sb = (WFSFS_SB *) &(wfsfs->sb);
+    TSK_FS_INFO *fs = (TSK_FS_INFO *) wfsfs;
+
+    TSK_INUM_T max_inode  = fs->root_inum;
+    if (dino_inum >= max_inode) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_INODE_NUM);
+        tsk_error_set_errstr("wfsfs_dinode_load: address: %" PRIuINUM ".\n",
+                dino_inum);
+        return 1;
+    }
+
+    if (to_load) {
+        if ((dino_buf = (WFSFS_INODE *) tsk_malloc(WFSFS_INODE_SIZE)) == NULL)
+            return 1;
+
+        addr = tsk_getu32(fs->endian, sb->s_first_index_block)
+                   * tsk_getu32(fs->endian, sb->s_block_size)
+                + dino_inum * WFSFS_INODE_SIZE;
+
+        cnt = tsk_fs_read(fs, addr, (char *) dino_buf, WFSFS_INODE_SIZE);
+
+        if (cnt != WFSFS_INODE_SIZE) {
+            free(dino_buf);
+            return 1;
+        }
+    }
+
+    time_t t_start = wfsfs_mktime(dino_buf->i_time_start);
+    char   t_start_buf[128];
+
+    time_t t_end = wfsfs_mktime(dino_buf->i_time_end);
+    char   t_end_buf[128];
+    int    is_main = dino_buf->i_type_desc[0] == 0x02 ||
+                     dino_buf->i_type_desc[1] == 0x03;
+
+     if (! to_load)  // Only shows if inode has been loaded
+        tsk_fprintf(stderr,
+            "Inode num= %" PRIuINUM "\n",
+            dino_inum);
+
+    tsk_fprintf(stderr,
+        "\tDescriptor type= %d (2 or 3 for main)\n"
+        "\tNext Fragment= %d\n"
+        "\tCreation time= %" PRIu64 " (%s)\n"
+        "\tModification time= %" PRIu64 " (%s)\n",
+        dino_buf->i_type_desc[0],
+        tsk_getu32(TSK_LIT_ENDIAN, dino_buf->i_next_frag),
+        t_start, tsk_fs_time_to_str(t_start, t_start_buf),
+        t_end, tsk_fs_time_to_str(t_end, t_end_buf),
+        wfsfs_mktime (dino_buf->i_time_end));
+
+    if (is_main)
+        tsk_fprintf(stderr,
+            "\t#Fragments= %d (size %ld bytes)\n",
+            tsk_getu16(TSK_LIT_ENDIAN, dino_buf->i_numb_frag) +1,
+            wfsfs_get_file_size(wfsfs, dino_buf));
+    else
+        tsk_fprintf(stderr,
+            "\tFragment number= %d\n",
+            tsk_getu16(TSK_LIT_ENDIAN, dino_buf->i_numb_frag));
+
+
+    if (to_load)
+        free(dino_buf);
+
+    return 0;
+}
+
+/* wfsfs_dinode_load - look up disk inode & load into wfsfs_inode structure
+ * @param wfsfs A wfsfs file system information structure
+ * @param dino_inum Metadata address
+ * @param dino_buf The buffer to store the block in (must be size of wfsfs->inode_size or larger)
+ *
+ * return 1 on error and 0 on success
+ * */
+
+static uint8_t
+wfsfs_dinode_load(WFSFS_INFO * wfsfs, TSK_INUM_T dino_inum,
+    WFSFS_INODE * dino_buf)
+{
+    TSK_OFF_T addr;
+    ssize_t cnt;
+    WFSFS_SB *sb = (WFSFS_SB *) &(wfsfs->sb);
+    TSK_FS_INFO *fs = (TSK_FS_INFO *) wfsfs;
+
+    TSK_INUM_T min_inode  = tsk_getu32(fs->endian, sb->s_num_reserv_frags);
+    TSK_INUM_T max_inode  = fs->root_inum;
+
+    if ((dino_inum < min_inode) ||
+        (dino_inum >= max_inode)) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_INODE_NUM);
+        tsk_error_set_errstr("wfsfs_dinode_load: address: %" PRIuINUM
+            " (valid: %" PRIuINUM "..%" PRIuINUM ").",
+            dino_inum, min_inode, max_inode-1);
+        return 1;
+    }
+
+    if (dino_buf == NULL) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr("wfsfs_dinode_load: dino_buf is NULL");
+        return TSK_ERR;
+    }
+
+    addr = tsk_getu32(fs->endian, sb->s_first_index_block)
+               * tsk_getu32(fs->endian, sb->s_block_size)
+            + dino_inum * WFSFS_INODE_SIZE;
+
+    cnt = tsk_fs_read(fs, addr, (char *) dino_buf, WFSFS_INODE_SIZE);
+
+    if (cnt != WFSFS_INODE_SIZE) {
+        if (cnt >= 0) {
+            tsk_error_reset();
+            tsk_error_set_errno(TSK_ERR_FS_READ);
+        }
+        tsk_error_set_errstr2("wfsfs_dinode_load: Inode %" PRIuINUM
+            " from %" PRIdOFF, dino_inum, addr);
+        return TSK_ERR;
+    }
+
+    if (dino_buf->i_type_desc[0] != 0x02 &&
+        dino_buf->i_type_desc[0] != 0x03) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_INODE_NUM);
+        tsk_error_set_errstr2("wfsfs_dinode_load: Inode %" PRIuINUM
+            " from %" PRIdOFF " is not valid.", dino_inum, addr);
+
+        return TSK_ERR;
+    }
+
+    if (tsk_verbose)
+        wfs_dump_inode(wfsfs, dino_inum, dino_buf);
+
+    return TSK_OK;
+}
+
+
+/* wfsfs_dinode_copy - copy cached disk inode into generic inode
+ *
+ * returns 1 on error and 0 on success
+ * */
+static uint8_t
+wfsfs_dinode_copy(WFSFS_INFO * wfsfs, TSK_FS_META * fs_meta,
+    TSK_INUM_T inum, const WFSFS_INODE * dino_buf)
+{
+    if (dino_buf == NULL) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr("wfsfs_dinode_copy: dino_buf is NULL");
+        return 1;
+    }
+
+    fs_meta->attr_state = TSK_FS_META_ATTR_EMPTY;
+    if (fs_meta->attr) {
+        tsk_fs_attrlist_markunused(fs_meta->attr);
+    }
+
+    fs_meta->type = TSK_FS_META_TYPE_REG;
+    fs_meta->mode = 0;
+    fs_meta->nlink = 1;
+    fs_meta->addr = inum;
+    fs_meta->flags = TSK_FS_META_FLAG_ALLOC;
+
+    fs_meta->atime = 0;
+    fs_meta->ctime = wfsfs_mktime(dino_buf->i_time_start);
+    fs_meta->mtime = wfsfs_mktime(dino_buf->i_time_end);
+    fs_meta->size = wfsfs_get_file_size(wfsfs, dino_buf);
+    fs_meta->seq = inum;
+
+    if (fs_meta->link) {
+        free(fs_meta->link);
+        fs_meta->link = NULL;
+    }
+
+    fs_meta->flags |= TSK_FS_META_FLAG_USED;
+
+    return 0;
+}
+
+
+/* wfsfs_inode_lookup - lookup inode, external interface
+ *
+ * Returns 1 on error and 0 on success
+ *
+ */
+
+static uint8_t
+wfsfs_inode_lookup(TSK_FS_INFO * fs, TSK_FS_FILE * a_fs_file,
+    TSK_INUM_T inum)
+{
+    WFSFS_INFO *wfsfs = (WFSFS_INFO *) fs;
+    WFSFS_INODE *dino_buf = NULL;
+    unsigned int size = 0;
+    
+    if (inum == fs->root_inum) {
+        a_fs_file->meta = wfsfs->root_inode;
+        return TSK_OK;
+    }
+
+    if (a_fs_file == NULL) {
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr("wfsfs_inode_lookup: fs_file is NULL");
+        return 1;
+    }
+
+    if (a_fs_file->meta == NULL) {
+        if ((a_fs_file->meta =
+                tsk_fs_meta_alloc(WFSFS_FILE_CONTENT_LEN)) == NULL)
+            return 1;
+    }
+    else {
+        tsk_fs_meta_reset(a_fs_file->meta);
+    }
+
+    size = WFSFS_INODE_SIZE;
+    if ((dino_buf = (WFSFS_INODE *) tsk_malloc(size)) == NULL) {
+        return 1;
+    }
+
+    if (wfsfs_dinode_load(wfsfs, inum, dino_buf)) {
+        free(dino_buf);
+        return TSK_ERR;
+    }
+
+    if (wfsfs_dinode_copy(wfsfs, a_fs_file->meta, inum, dino_buf)) {
+        free(dino_buf);
+        return TSK_ERR;
+    }
+
+    free(dino_buf);
+    return TSK_OK;
+}
+
+
+TSK_FS_ATTR_TYPE_ENUM
+wfsfs_get_default_attr_type(const TSK_FS_FILE * a_file)
+{
+    return TSK_FS_ATTR_TYPE_DEFAULT;
+}
+
+
+/** \internal
+ * Add the data runs and extents to the file attributes.
+ *
+ * @param fs_file File system to analyze
+ * @returns 0 on success, 1 otherwise
+ */
+static uint8_t
+wfsfs_load_attrs(TSK_FS_FILE * fs_file)
+{
+    TSK_FS_ATTR  *fs_attr;
+    TSK_FS_META  *fs_meta = fs_file->meta;
+    TSK_FS_INFO  *fs = fs_file->fs_info;
+    WFSFS_INFO  *wfsfs = (WFSFS_INFO *) fs;
+    WFSFS_SB    *sb = &(wfsfs->sb);
+    WFSFS_INODE  inode_blk;
+    ssize_t       cnt;
+
+    // clean up any error messages that are lying around
+    tsk_error_reset();
+
+    if (tsk_verbose)
+        tsk_fprintf(stderr,
+            "wfsfs_load_attrs: Processing file %" PRIuINUM "\n",
+            fs_meta->addr);
+
+    // see if we have already loaded the runs
+    if ((fs_meta->attr != NULL)
+        && (fs_meta->attr_state == TSK_FS_META_ATTR_STUDIED)) {
+        return 0;
+    }
+
+    if (fs_meta->attr_state == TSK_FS_META_ATTR_ERROR) {
+        return 1;
+    }
+
+    if (TSK_FS_TYPE_ISWFS(fs->ftype) == 0) {
+        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);
+        tsk_error_set_errstr
+            ("wfsfs_load_attrs: Called with non-WFS0.4/5 file system: %x",
+            fs->ftype);
+        return 1;
+    }
+
+    if (tsk_verbose) {
+        tsk_fprintf(stderr,
+            "wfsfs_load_attrs: Processing file %" PRIuINUM
+            " in normal mode\n", fs_meta->addr);
+    }
+
+    TSK_FS_ATTR_RUN *data_run = NULL;
+    TSK_FS_ATTR_RUN *data_run_head = NULL;
+    TSK_DADDR_T index_start_blk = tsk_getu32(fs->endian, sb->s_first_index_block);
+
+    int blocks_per_frag = tsk_getu32(fs->endian, sb->s_blocks_per_frag);
+    int block_size = tsk_getu32(fs->endian, sb->s_block_size);
+
+    int cur_frag = fs_meta->addr;
+    TSK_OFF_T size_remain = fs_meta->size;
+
+    while (size_remain > 0) {
+        TSK_DADDR_T cur_block = WFSFS_FRAG_2_BLOCK(sb, cur_frag);
+
+        if (cur_block > fs->last_block) {
+            fs_meta->attr_state = TSK_FS_META_ATTR_ERROR;
+            tsk_error_reset();
+
+            tsk_error_set_errno(TSK_ERR_FS_INODE_COR);
+            tsk_error_set_errstr
+                ("wfsfs_load_attrs: Invalid block address in WFS: %"
+                PRIuDADDR " (block size: %d bytes)", cur_block, block_size);
+            return 1;
+        }
+
+        // see if we need a new run
+        TSK_FS_ATTR_RUN *data_run_tmp = tsk_fs_attr_run_alloc();
+        if (data_run_tmp == NULL) {
+            tsk_fs_attr_run_free(data_run_head);
+            fs_meta->attr_state = TSK_FS_META_ATTR_ERROR;
+            return 1;
+        }
+
+        data_run_tmp->len = (size_remain/block_size) < blocks_per_frag ?
+                            (size_remain/block_size) : blocks_per_frag;
+        data_run_tmp->addr = cur_block;
+
+        if (data_run_head == NULL) {
+            data_run_head = data_run_tmp;
+            data_run_tmp->offset = 0;
+        }
+        else {
+            data_run->next = data_run_tmp;
+            data_run_tmp->offset = data_run->offset + data_run->len;
+        }
+        data_run = data_run_tmp;
+
+        if ((int64_t) size_remain > 0) {
+            size_remain -= (data_run->len * block_size);
+
+            TSK_DADDR_T inode_addr = index_start_blk * block_size +
+                                        cur_frag * WFSFS_INODE_SIZE;
+            cnt = tsk_fs_read(fs, inode_addr,
+                        (char *) &inode_blk, WFSFS_INODE_SIZE);
+
+            if (cnt != WFSFS_INODE_SIZE) {
+                if (cnt >= 0) {
+                    tsk_error_reset();
+                    tsk_error_set_errno(TSK_ERR_FS_READ);
+                }
+                tsk_error_set_errstr2("wfsfs_load_attrs: Inode %d"
+                    " from %" PRIuDADDR, cur_frag, inode_addr);
+                return 1;
+            }
+
+            cur_frag = tsk_getu32(fs->endian, inode_blk.i_next_frag);
+        }
+    }
+
+    if ((fs_meta->attr == NULL) &&
+        ((fs_meta->attr = tsk_fs_attrlist_alloc()) == NULL)) {
+        fs_meta->attr_state = TSK_FS_META_ATTR_ERROR;
+        return 1;
+    }
+
+    // add the run list to the inode structure
+    if ((fs_attr =
+            tsk_fs_attrlist_getnew(fs_meta->attr,
+                TSK_FS_ATTR_RES)) == NULL) {
+        fs_meta->attr_state = TSK_FS_META_ATTR_ERROR;
+        return 1;
+    }
+
+    // initialize the data run
+    if (tsk_fs_attr_set_run(fs_file, fs_attr, data_run_head, NULL,
+            TSK_FS_ATTR_TYPE_DEFAULT, TSK_FS_ATTR_ID_DEFAULT,
+            fs_meta->size, fs_meta->size, fs_meta->size, 0, 0)) {
+        fs_meta->attr_state = TSK_FS_META_ATTR_ERROR;
+        return 1;
+    }
+
+    fs_meta->attr_state = TSK_FS_META_ATTR_STUDIED;
+
+    return TSK_OK;
+}
+
+TSK_FS_BLOCK_FLAG_ENUM
+wfsfs_block_getflags(TSK_FS_INFO * a_fs, TSK_DADDR_T a_addr)
+{
+    WFSFS_INFO* wfsfs = (WFSFS_INFO*) a_fs;
+    uint32_t s_blocks_per_frag = tsk_getu32(a_fs->endian,
+        wfsfs->sb.s_blocks_per_frag);
+    TSK_DADDR_T s_first_data_block = 
+        tsk_getu32(a_fs->endian, wfsfs->sb.s_first_data_block);
+    TSK_DADDR_T s_newest_data_block =
+        s_first_data_block +
+        s_blocks_per_frag *
+        (tsk_getu32(a_fs->endian, wfsfs->sb.s_index_last_frag) + 1) - 1;
+    TSK_DADDR_T s_oldest_data_block =
+        s_first_data_block +
+        s_blocks_per_frag *
+        tsk_getu32(a_fs->endian, wfsfs->sb.s_index_first_frag);
+    TSK_DADDR_T s_last_reserved_data_block =
+        s_first_data_block +
+        s_blocks_per_frag *
+        (tsk_getu32(a_fs->endian, wfsfs->sb.s_num_reserv_frags) + 1) - 1;
+
+    if (a_addr < s_first_data_block)
+        return TSK_FS_BLOCK_FLAG_META | TSK_FS_BLOCK_FLAG_ALLOC;
+
+    if (a_addr <= s_last_reserved_data_block)
+        return TSK_FS_BLOCK_FLAG_CONT | TSK_FS_BLOCK_FLAG_UNALLOC;
+
+    if (a_addr <= s_newest_data_block)
+        return TSK_FS_BLOCK_FLAG_CONT | TSK_FS_BLOCK_FLAG_ALLOC;
+
+    if (a_addr >= s_oldest_data_block)
+        return TSK_FS_BLOCK_FLAG_CONT | TSK_FS_BLOCK_FLAG_ALLOC;
+
+    return TSK_FS_BLOCK_FLAG_CONT | TSK_FS_BLOCK_FLAG_UNALLOC;
+}
+
+/* wfsfs_block_walk - block iterator
+ *
+ * flags: TSK_FS_BLOCK_FLAG_ALLOC, TSK_FS_BLOCK_FLAG_UNALLOC, TSK_FS_BLOCK_FLAG_CONT,
+ *  TSK_FS_BLOCK_FLAG_META
+ *
+ *  Return 1 on error and 0 on success
+*/
+
+uint8_t
+wfsfs_block_walk(TSK_FS_INFO * a_fs, TSK_DADDR_T a_start_blk,
+    TSK_DADDR_T a_end_blk, TSK_FS_BLOCK_WALK_FLAG_ENUM a_flags,
+    TSK_FS_BLOCK_WALK_CB a_action, void *a_ptr)
+{
+    char* myname = "wfsfs_block_walk";
+    TSK_FS_BLOCK* fs_block;
+    TSK_DADDR_T addr;
+
+    // clean up any error messages that are lying around
+    tsk_error_reset();
+
+    /*
+     * Sanity checks.
+     */
+    if (a_start_blk < a_fs->first_block || a_start_blk > a_fs->last_block) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);
+        tsk_error_set_errstr("%s: start block: %" PRIuDADDR, myname,
+            a_start_blk);
+        return TSK_ERR;
+    }
+    if (a_end_blk < a_fs->first_block || a_end_blk > a_fs->last_block
+        || a_end_blk < a_start_blk) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);
+        tsk_error_set_errstr("%s: end block: %" PRIuDADDR, myname,
+            a_end_blk);
+        return TSK_ERR;
+    }
+
+    /* Sanity check on a_flags -- make sure at least one ALLOC is set */
+    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC) == 0) &&
+        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC) == 0)) {
+        a_flags |=
+            (TSK_FS_BLOCK_WALK_FLAG_ALLOC |
+                TSK_FS_BLOCK_WALK_FLAG_UNALLOC);
+    }
+    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_META) == 0) &&
+        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT) == 0)) {
+        a_flags |=
+            (TSK_FS_BLOCK_WALK_FLAG_CONT | TSK_FS_BLOCK_WALK_FLAG_META);
+    }
+
+    if ((fs_block = tsk_fs_block_alloc(a_fs)) == NULL) {
+        return TSK_ERR;
+    }
+
+    for (addr = a_start_blk; addr <= a_end_blk; addr++) {
+        int retval;
+        int myflags;
+
+        myflags = wfsfs_block_getflags(a_fs, addr);
+
+        // test if we should call the callback with this one
+        if ((myflags & TSK_FS_BLOCK_FLAG_META)
+            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_META)))
+            continue;
+        else if ((myflags & TSK_FS_BLOCK_FLAG_CONT)
+            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT)))
+            continue;
+        else if ((myflags & TSK_FS_BLOCK_FLAG_ALLOC)
+            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC)))
+            continue;
+        else if ((myflags & TSK_FS_BLOCK_FLAG_UNALLOC)
+            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC)))
+            continue;
+
+        if (a_flags & TSK_FS_BLOCK_WALK_FLAG_AONLY)
+            myflags |= TSK_FS_BLOCK_FLAG_AONLY;
+
+        if (tsk_fs_block_get_flag(a_fs, fs_block, addr, myflags) == NULL) {
+            tsk_error_set_errstr2("%s: block %" PRIuDADDR,
+                myname, addr);
+            tsk_fs_block_free(fs_block);
+            return 1;
+        }
+
+        retval = a_action(fs_block, a_ptr);
+        if (retval == TSK_WALK_STOP) {
+            break;
+        }
+        else if (retval == TSK_WALK_ERROR) {
+            tsk_fs_block_free(fs_block);
+            return 1;
+        }
+    }
+
+    tsk_fs_block_free(fs_block);
+    return TSK_OK;
+}
+
+/* return 1 on error and 0 on success */
+uint8_t
+wfsfs_inode_walk(TSK_FS_INFO * fs,
+        TSK_INUM_T a_start_inum, TSK_INUM_T a_end_inum,
+        TSK_FS_META_FLAG_ENUM a_flags, TSK_FS_META_WALK_CB a_action,
+        void *a_ptr)
+{
+    tsk_error_reset();
+    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);
+    tsk_error_set_errstr("inode_walk not implemented for WFS0.4/5");
+    return TSK_ERR;
+}
+
+/* return 1 on error and 0 on success */
+uint8_t
+wfsfs_jopen(TSK_FS_INFO * fs, TSK_INUM_T inum)
+{
+    tsk_error_reset();
+    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);
+    tsk_error_set_errstr("WFS0.4/5 does not have a journal");
+    return 1;
+}
+
+/* return 1 on error and 0 on success */
+uint8_t
+wfsfs_fscheck(TSK_FS_INFO * fs, FILE * hFile)
+{
+    tsk_error_reset();
+    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);
+    tsk_error_set_errstr("fscheck not implemented for WFS0.4/5 yet");
+    return 1;
+}
+
+/* return 1 on error and 0 on success */
+uint8_t
+wfsfs_jentry_walk(TSK_FS_INFO * fs, int a_flags,
+    TSK_FS_JENTRY_WALK_CB a_action, void *a_ptr)
+{
+    tsk_error_reset();
+    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);
+    tsk_error_set_errstr("WFS0.4/5 does not have a journal");
+    return 1;
+}
+
+/* return 1 on error and 0 on success */
+uint8_t
+wfsfs_jblk_walk(TSK_FS_INFO * fs, TSK_DADDR_T start, TSK_DADDR_T end,
+    int a_flags, TSK_FS_JBLK_WALK_CB a_action, void *a_ptr)
+{
+    tsk_error_reset();
+    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);
+    tsk_error_set_errstr("WFS0.4/5 does not have a journal");
+    return 1;
+}
+
+
+/**
+ * Print details about the file system to a file handle.
+ *
+ * @param fs File system to print details on
+ * @param hFile File handle to print text to
+ *
+ * @returns 1 on error and 0 on success
+ */
+static uint8_t
+wfsfs_fsstat(TSK_FS_INFO * fs, FILE * hFile)
+{
+    WFSFS_INFO *wfsfs = (WFSFS_INFO *) fs;
+    WFSFS_SB *sb = &(wfsfs->sb);
+    time_t tmptime;
+    char timeBuf[128];
+    const char *tmptypename;
+
+
+    // clean up any error messages that are lying around
+    tsk_error_reset();
+
+    tsk_fprintf(hFile, "FILE SYSTEM INFORMATION\n");
+    tsk_fprintf(hFile, "--------------------------------------------\n");
+
+    switch (fs->ftype) {
+    case TSK_FS_TYPE_WFS_04:
+        tmptypename = "WFS0.4";
+        break;
+    case TSK_FS_TYPE_WFS_05:
+        tmptypename = "WFS0.5";
+        break;
+    default:
+        tmptypename = "WFS0.4";
+    }
+
+    tsk_fprintf(hFile, "File System Type: %s\n", tmptypename);
+    tsk_fprintf(hFile, "Block size (in bytes): %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_block_size));
+    tsk_fprintf(hFile, "Blocks per fragment: %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_blocks_per_frag));
+    tsk_fprintf(hFile, "Fragment size (in bytes): %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_block_size) *
+        tsk_getu32(fs->endian, sb->s_blocks_per_frag));
+    tsk_fprintf(hFile, "Root inode (virtual): %" PRIu64 "\n",
+        fs->root_inum);
+
+    tsk_fprintf(hFile, "\nTIMESTAMPS:\n");
+    tsk_fprintf(hFile, "--------------------------------------------\n");
+    tmptime = wfsfs_mktime(sb->s_time_first_creation);
+    tsk_fprintf(hFile, "First fragment creation: %s\n",
+        (tmptime > 0) ? tsk_fs_time_to_str(tmptime, timeBuf) : "empty");
+
+    tmptime = wfsfs_mktime(sb->s_time_last_modification);
+    tsk_fprintf(hFile, "Last fragment modification: %s\n",
+        (tmptime > 0) ? tsk_fs_time_to_str(tmptime, timeBuf) : "empty");
+
+    tmptime = wfsfs_mktime(sb->s_time_oldest_creation);
+    tsk_fprintf(hFile, "Oldest fragment creation: %s\n",
+        (tmptime > 0) ? tsk_fs_time_to_str(tmptime, timeBuf) : "empty");
+
+    tmptime = wfsfs_mktime(sb->s_time_newest_modification);
+    tsk_fprintf(hFile, "Newest Fragment modification: %s\n",
+        (tmptime > 0) ? tsk_fs_time_to_str(tmptime, timeBuf) : "empty");
+
+    tsk_fprintf(hFile, "\nDISK FRAGMENTS:\n");
+    tsk_fprintf(hFile, "--------------------------------------------\n");
+    tsk_fprintf(hFile, "Number of fragments: %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_total_indexes));
+
+    tsk_fprintf(hFile, "First fragment number (after reserveds): %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_num_reserv_frags));
+    wfs_dump_inode(wfsfs, tsk_getu32(fs->endian, sb->s_num_reserv_frags),
+                        NULL);
+    tsk_fprintf(hFile, "Last fragment number: %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_last_index_valid));
+    wfs_dump_inode(wfsfs, tsk_getu32(fs->endian, sb->s_last_index_valid),
+                        NULL);
+
+    tsk_fprintf(hFile, "Newest fragment number: %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_index_last_frag));
+    wfs_dump_inode(wfsfs, tsk_getu32(fs->endian, sb->s_index_last_frag),
+                        NULL);
+
+    tsk_fprintf(hFile, "Oldest fragment number: %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_index_first_frag));
+    wfs_dump_inode(wfsfs, tsk_getu32(fs->endian, sb->s_index_first_frag),
+                        NULL);
+
+    tsk_fprintf(hFile, "\nDISK AREAS:\n");
+    tsk_fprintf(hFile, "--------------------------------------------\n");
+    tsk_fprintf(hFile, "Block size (in bytes): %" PRIu32 "\n",
+        tsk_getu32(fs->endian, sb->s_block_size));
+    tsk_fprintf(hFile, "Superblock block: %" PRIu32 " (%" PRIu32 ")\n",
+        WFSFS_SBOFF / tsk_getu32(fs->endian, sb->s_block_size),
+        WFSFS_SBOFF);
+    tsk_fprintf(hFile, "Index area start block: %" PRIu32 " (%" PRIu32 ")\n",
+        tsk_getu32(fs->endian, sb->s_first_index_block),
+        tsk_getu32(fs->endian, sb->s_first_index_block) * 
+        tsk_getu32(fs->endian, sb->s_block_size));
+    tsk_fprintf(hFile, "Data area start block: %" PRIu32 " (%" PRIu32 ")\n",
+        tsk_getu32(fs->endian, sb->s_first_data_block),
+        tsk_getu32(fs->endian, sb->s_first_data_block) * 
+        tsk_getu32(fs->endian, sb->s_block_size));
+
+    return 0;
+}
+
+/**
+ * Print details on a specific file to a file handle.
+ *
+ * @param fs File system file is located in
+ * @param hFile File handle to print text to
+ * @param inum Address of file in file system
+ * @param numblock The number of blocks in file to force print (can go beyond file size)
+ * @param sec_skew Clock skew in seconds to also print times in
+ *
+ * @returns 1 on error and 0 on success
+ */
+static uint8_t
+wfsfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TSK_INUM_T inum,
+    TSK_DADDR_T numblock, int32_t sec_skew)
+{
+    TSK_FS_META *fs_meta;
+    TSK_FS_FILE *fs_file;
+    WFSFS_INFO* wfsfs = (WFSFS_INFO *) fs;
+
+    WFSFS_INODE *dino_buf = NULL;
+    char timeBuf[128];
+
+    // clean up any error messages that are lying around
+    tsk_error_reset();
+
+    if (inum == fs->root_inum)
+        fs_meta = wfsfs->root_inode;
+    else if (inum < fs->root_inum) {
+        // Call wfsfs_inode_lookup. All errors checked there.
+        if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {
+            return TSK_ERR;
+        }
+        fs_meta = fs_file->meta;
+    }
+         
+    if (inum != fs->root_inum) {
+        tsk_fprintf(hFile, "Video : %" PRIuINUM "\n", inum);
+        tsk_fprintf(hFile, "size: %" PRIdOFF "\n", fs_meta->size);
+        tsk_fprintf(hFile, "#frags: %" PRIdOFF "\n", (fs_meta->size - 1) /
+            (tsk_getu32(fs->endian, wfsfs->sb.s_blocks_per_frag) *
+                tsk_getu32(fs->endian, wfsfs->sb.s_block_size)) + 1);
+        tsk_fprintf(hFile, "num of links: %d\n", fs_meta->nlink);
+
+        tsk_fprintf(hFile, "File Created:\t%s\n",
+            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));
+        tsk_fprintf(hFile, "File Modified:\t%s\n",
+            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));
+        if (istat_flags & TSK_FS_ISTAT_RUNLIST) {
+            tsk_fprintf(hFile, "\nFragments (values in blocks of %" 
+                PRIu32 " bytes):\n",
+                        tsk_getu32(fs->endian, wfsfs->sb.s_block_size));
+            const TSK_FS_ATTR* fs_attr_default =
+                tsk_fs_file_attr_get_type(fs_file,
+                    TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);
+            if (tsk_fs_attr_print(fs_attr_default, hFile)) {
+                tsk_fprintf(hFile, "\nError creating run lists\n");
+                tsk_error_print(hFile);
+                tsk_error_reset();
+            }
+        }
+    }
+    else {
+        tsk_fprintf(hFile, "This is the virtual root inode.\n");
+    }
+
+    tsk_fs_file_close(fs_file);
+    return TSK_OK;
+}
+
+
+/* wfsfs_close - close an wfsfs file system */
+static void
+wfsfs_close(TSK_FS_INFO * fs)
+{
+    fs->tag = 0;
+    tsk_fs_meta_close(((WFSFS_INFO*)fs)->root_inode);
+    tsk_fs_free(fs);
+}
+
+
+/**
+ * \internal
+ * Open part of a disk image as a WFS0.4/5 file system.
+ *
+ * @param img_info Disk image to analyze
+ * @param offset Byte offset where file system starts
+ * @param ftype Specific type of file system
+ * @param test NOT USED
+ * @returns NULL on error or if data is not an WFS0.4/5 file system
+ */
+TSK_FS_INFO *
+wfsfs_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,
+    TSK_FS_TYPE_ENUM ftype, uint8_t test)
+{
+    unsigned int len;
+    WFSFS_INFO  *wfsfs;
+    TSK_FS_INFO  *fs;
+    WFSFS_SB     *sb;
+    wfsfs_header fs_header;   /* header block */
+    ssize_t cnt;
+
+    // clean up any error messages that are lying around
+    tsk_error_reset();
+
+    if (TSK_FS_TYPE_ISWFS(ftype) == 0) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr("Invalid FS Type in wfsfs_open");
+        return NULL;
+    }
+
+    if (img_info->sector_size == 0) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr("wfsfs_open: sector size is 0");
+        return NULL;
+    }
+
+    if ((wfsfs = (WFSFS_INFO *) tsk_fs_malloc(sizeof(*wfsfs))) == NULL)
+        return NULL;
+
+    fs = &(wfsfs->fs_info);
+    sb = &(wfsfs->sb);
+
+    fs->ftype = ftype;
+    fs->flags = TSK_FS_INFO_FLAG_NONE;
+    fs->img_info = img_info;
+    fs->offset = offset;
+    fs->tag = TSK_FS_INFO_TAG;
+
+    /*
+     * Read the header.
+     */
+    len = sizeof(fs_header);
+    cnt = tsk_fs_read(fs, WFSFS_HEADOFS, (char *) &fs_header, len);
+    if (cnt != len) {
+        if (cnt >= 0) {
+            tsk_error_reset();
+            tsk_error_set_errno(TSK_ERR_FS_READ);
+        }
+        tsk_error_set_errstr2("wfsfs_open: header");
+        fs->tag = 0;
+        tsk_fs_free((TSK_FS_INFO *)wfsfs);
+        return NULL;
+    }
+
+    /*
+     * Verify we are looking at an WFS image
+     */
+    if (strncmp((char *) &fs_header, WFSFS_MAGIC_WFS04,
+                strlen(WFSFS_MAGIC_WFS04)) != 0 &&
+        strncmp((char *) &fs_header, WFSFS_MAGIC_WFS05,
+                strlen(WFSFS_MAGIC_WFS05)) != 0) {
+        fs->tag = 0;
+        tsk_fs_free((TSK_FS_INFO *)wfsfs);
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_MAGIC);
+        tsk_error_set_errstr("not an WFS0.4/5 file system (magic)");
+        if (tsk_verbose)
+            fprintf(stderr, "wfsfs_open: invalid magic\n");
+        return NULL;
+    }
+
+    cnt = tsk_fs_read(fs, WFSFS_SBOFF, (char *) sb, len);
+    if (cnt != len) {
+        if (cnt >= 0) {
+            tsk_error_reset();
+            tsk_error_set_errno(TSK_ERR_FS_READ);
+        }
+        tsk_error_set_errstr2("wfsfs_open: superblock");
+        fs->tag = 0;
+        tsk_fs_free((TSK_FS_INFO *)wfsfs);
+        return NULL;
+    }
+
+    /*
+     * Calculate the meta data info
+     */
+    fs->endian = TSK_LIT_ENDIAN;
+    fs->block_size = tsk_getu32(fs->endian, sb->s_block_size);
+    fs->dev_bsize = img_info->sector_size;
+    fs->first_block = 0;
+    fs->inum_count = tsk_getu32(fs->endian, sb->s_total_indexes); 
+    fs->last_inum = fs->inum_count;
+    fs->root_inum = fs->inum_count;
+    fs->first_inum = tsk_getu32(fs->endian, sb->s_num_reserv_frags);
+    fs->block_count = tsk_getu32(fs->endian, sb->s_first_data_block) +
+                      tsk_getu32(fs->endian, sb->s_total_indexes) *
+                      tsk_getu32(fs->endian, sb->s_blocks_per_frag);
+    fs->last_block_act = fs->last_block = fs->block_count - 1;
+
+    // sanity check
+    if (fs->block_size % 512) {
+        fs->tag = 0;
+        tsk_fs_free((TSK_FS_INFO *)wfsfs);
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_MAGIC);
+        tsk_error_set_errstr("Not an WFS04/5 file system (block size)");
+        if (tsk_verbose)
+            fprintf(stderr, "wfsfs_open: invalid block size\n");
+        return NULL;
+    }
+
+    // determine the last block we have in this image
+    if ((TSK_DADDR_T) ((img_info->size - offset) / fs->block_size) <
+        fs->block_count)
+        fs->last_block_act =
+            (img_info->size - offset) / fs->block_size - 1;
+
+    /* Set the generic function pointers */
+    fs->inode_walk = wfsfs_inode_walk;
+    fs->block_walk = wfsfs_block_walk;
+    fs->block_getflags = wfsfs_block_getflags;
+
+    fs->get_default_attr_type = wfsfs_get_default_attr_type;
+    fs->load_attrs = wfsfs_load_attrs;
+
+    fs->file_add_meta = wfsfs_inode_lookup;
+    fs->dir_open_meta = wfsfs_dir_open_meta;
+    fs->fsstat = wfsfs_fsstat;
+    fs->istat = wfsfs_istat;
+
+    fs->fscheck = wfsfs_fscheck;
+    fs->name_cmp = tsk_fs_unix_name_cmp;
+    fs->close = wfsfs_close;
+
+    /* Journal */
+    fs->jblk_walk = wfsfs_jblk_walk;
+    fs->jentry_walk = wfsfs_jentry_walk;
+    fs->jopen = wfsfs_jopen;
+
+    wfsfs->root_inode = NULL;
+    if (wfsfs_gen_root(wfsfs, fs->root_inum)) {
+        fs->tag = 0;
+        tsk_fs_free((TSK_FS_INFO*)wfsfs);
+        tsk_error_reset();
+        tsk_error_set_errstr("wfsfs_open: error in generation of root inode.");
+        if (tsk_verbose)
+            fprintf(stderr, "wfsfs_open: wfsfs_open: error in generation root inode.\n");
+        return NULL;
+    }
+
+    /*
+     * Print some stats.
+     */
+    if (tsk_verbose)
+        tsk_fprintf(stderr,
+            "Image / File system details:"
+            "\n\t#blocks/last block: %" PRIu64 "/%" PRIu64
+            "\n\t#First index/data block: %" PRIu64 "/%" PRIu64
+            "\n\tFragments %" PRIu32 " blocks/fragment %" PRIu32
+            "\n",
+            fs->last_block, fs->block_count,
+            tsk_getu32(fs->endian, sb->s_first_index_block),
+            tsk_getu32(fs->endian, sb->s_first_data_block),
+            tsk_getu32(fs->endian, sb->s_total_indexes),
+            tsk_getu32(fs->endian, sb->s_blocks_per_frag));
+
+    return (TSK_FS_INFO*) wfsfs;
+}
diff --git a/tsk/fs/wfsfs_dent.c b/tsk/fs/wfsfs_dent.c
new file mode 100644
index 00000000..e41b574f
--- /dev/null
+++ b/tsk/fs/wfsfs_dent.c
@@ -0,0 +1,267 @@
+/*
+** wfsfs_dent
+** The Sleuth Kit
+**
+** File name layer support for an WFS 0.4/0.5
+**
+** Brian Carrier [carrier <at> sleuthkit [dot] org]
+** Copyright (c) 2006-2011 Brian Carrier, Basis Technology.  All Rights reserved
+** Copyright (c) 2003-2006 Brian Carrier.  All rights reserved
+**
+** TASK
+** Copyright (c) 2002 Brian Carrier, @stake Inc.  All rights reserved
+**
+** TCTUTILS
+** Copyright (c) 2001 Brian Carrier.  All rights reserved
+**
+**
+** This software is distributed under the Common Public License 1.0
+**
+*/
+
+/**
+ * \file wfsfs_dent.c
+ * Contains the internal TSK file name processing code for WFS0.4/0.5
+ */
+
+/* WFS Decoder
+ * LICENSE
+ *	This software is distributed under GNU Public License.
+ * AUTHOR(S)
+ *	Galileu Batista (gbat2k ... gbatmobile)
+ *	Brazilian Federal Police & Federal Institute of Technonoly in RN
+ *	Natal, RN, BRAZIL
+ *
+ * Copyright (c) 2020 Galileu Batista.  All rights reserved
+ *
+ --*/
+
+#include <ctype.h>
+#include "tsk_fs_i.h"
+#include "tsk_wfsfs.h"
+
+
+static void
+wfsfs_gen_dentry (TSK_INUM_T i_num,
+    char *wfs_inode,  TSK_FS_NAME * fs_name)
+{
+    WFSFS_INODE *dir = (WFSFS_INODE *) wfs_inode;
+
+    if (tsk_verbose)
+        tsk_fprintf(stderr, "wfsfs_gen_dentry: Processing dir_entry %"
+                PRIu64 ": camera %d\n",i_num,
+                WFSFS_CAM_NUM(dir->i_camera[0]));
+
+    time_t stime = wfsfs_mktime(dir->i_time_start);
+    struct tm *stmTime = localtime(&stime);
+    /* localtime is not reentrant. So we need save values
+       before call again. */
+    int year   = stmTime->tm_year + 1900;
+    int month  = stmTime->tm_mon + 1;
+    int day    = stmTime->tm_mday;
+    int s_hour = stmTime->tm_hour;
+    int s_min  = stmTime->tm_min;
+    int s_sec  = stmTime->tm_sec;
+
+    time_t etime = wfsfs_mktime(dir->i_time_end);
+    struct tm *etmTime = localtime(&etime);
+
+    sprintf(fs_name->name,
+            "Vid-%04d%02d%02d-%02d%02d%02d-%02d%02d%02d.%03d.h264",
+            year, month, day, s_hour, s_min, s_sec,
+            etmTime->tm_hour, etmTime->tm_min, etmTime->tm_sec,
+            WFSFS_CAM_NUM(dir->i_camera[0]));
+
+
+    fs_name->meta_addr = i_num;
+    fs_name->name_size = strlen(fs_name->name);
+    fs_name->type = TSK_FS_NAME_TYPE_REG;
+    fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;
+}
+
+static void
+wfsfs_gen_dir_name (TSK_INUM_T i_num,
+        const char *name,  TSK_FS_NAME * fs_name)
+{
+    strcpy(fs_name->name, name);
+    fs_name->meta_addr = i_num;
+    fs_name->name_size = strlen(fs_name->name);
+    fs_name->par_addr = i_num;
+    fs_name->type = TSK_FS_NAME_TYPE_DIR;
+    fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;
+}
+
+TSK_RETVAL_ENUM
+wfsfs_gen_root (WFSFS_INFO * wfsfs, TSK_INUM_T i_num)
+{
+    TSK_FS_META* fs_meta = wfsfs->root_inode;
+    if ((fs_meta == NULL) && (fs_meta = tsk_fs_meta_alloc(0)) == NULL)
+        return TSK_ERR;
+
+    wfsfs->root_inode = fs_meta;
+    fs_meta->tag = TSK_FS_DIR_TAG;
+    fs_meta->type = TSK_FS_META_TYPE_DIR;
+    // set the mode
+    fs_meta->mode = 0;
+    fs_meta->nlink = 3;
+    fs_meta->addr = i_num;
+    fs_meta->flags = TSK_FS_META_FLAG_ALLOC;
+    fs_meta->atime = 0;
+    fs_meta->ctime = wfsfs_mktime(wfsfs->sb.s_time_oldest_creation);
+    fs_meta->mtime = wfsfs_mktime(wfsfs->sb.s_time_newest_modification);
+    fs_meta->size = 0;
+    fs_meta->seq = i_num;
+    fs_meta->nlink = 1;
+    fs_meta->flags |= TSK_FS_META_FLAG_USED;
+
+    return TSK_OK;
+}
+
+/** \internal
+* Process a directory and load up FS_DIR with the entries. If a pointer to
+* an already allocated FS_DIR structure is given, it will be cleared.  If no existing
+* FS_DIR structure is passed (i.e. NULL), then a new one will be created. If the return
+* value is error or corruption, then the FS_DIR structure could
+* have entries (depending on when the error occurred).
+*
+* @param a_fs File system to analyze
+* @param a_fs_dir Pointer to FS_DIR pointer. Can contain an already allocated
+* structure or a new structure.
+* @param a_addr Address of directory to process.
+* @returns error, corruption, ok etc.
+*/
+
+TSK_RETVAL_ENUM
+wfsfs_dir_open_meta(TSK_FS_INFO * a_fs, TSK_FS_DIR ** a_fs_dir, TSK_INUM_T i_num)
+{
+    WFSFS_INFO *wfsfs = (WFSFS_INFO *) a_fs;
+    TSK_FS_DIR *fs_dir;
+    ssize_t     cnt;
+    uint32_t    inode_blk_ind, inode_ind, inode_ofs;
+    uint8_t     *inode_blk;
+    TSK_DADDR_T addr;
+    TSK_INUM_T  max_inode;
+
+    if (i_num != a_fs->root_inum) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);
+        tsk_error_set_errstr("wfsfs_dir_open_meta: inode value: %"
+            PRIuINUM "\n", i_num);
+        return TSK_ERR;
+    }
+    else if (a_fs_dir == NULL) {
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_FS_ARG);
+        tsk_error_set_errstr
+            ("wfsfs_dir_open_meta: NULL fs_attr argument given");
+        return TSK_ERR;
+    }
+
+    if (tsk_verbose) {
+        tsk_fprintf(stderr,
+            "wfsfs_dir_open_meta: Processing directory %" PRIuINUM
+            "\n", i_num);
+    }
+
+    fs_dir = *a_fs_dir;
+    if (fs_dir) {
+        tsk_fs_dir_reset(fs_dir);
+        fs_dir->addr = i_num;
+    }
+    else {
+        if ((*a_fs_dir = fs_dir =
+                tsk_fs_dir_alloc(a_fs, i_num, 512)) == NULL) {
+            return TSK_ERR;
+        }
+    }
+
+    TSK_FS_NAME *fs_name = tsk_fs_name_alloc(WFSFS_MAXNAMLEN, 0);
+    if (fs_name == NULL) {
+        tsk_fs_dir_close(fs_dir);
+        return TSK_ERR;
+    }
+
+    if ((fs_dir->fs_file = tsk_fs_file_alloc(a_fs)) == NULL) {
+        tsk_fs_name_free(fs_name);
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_AUX_MALLOC);
+        tsk_error_set_errstr
+            ("wfsfs_dir_open_meta: Error in memory allocation for dir.");
+        return TSK_ERR;
+    }
+    fs_dir->addr = i_num;
+
+    wfsfs_gen_dir_name(a_fs->root_inum, ".", fs_name);
+    if (tsk_fs_dir_add(fs_dir, fs_name)) {
+        tsk_fs_name_free(fs_name);
+        return TSK_ERR;
+    }
+
+    wfsfs_gen_dir_name(a_fs->root_inum, "..", fs_name);
+    if (tsk_fs_dir_add(fs_dir, fs_name)) {
+        tsk_fs_name_free(fs_name);
+        return TSK_ERR;
+    }
+
+    if ((inode_blk = (uint8_t *) tsk_malloc(a_fs->block_size)) == NULL) {
+        tsk_fs_name_free(fs_name);
+        tsk_error_reset();
+        tsk_error_set_errno(TSK_ERR_AUX_MALLOC);
+        tsk_error_set_errstr
+        ("wfsfs_dir_open_meta: Error in memory allocation for disk block.");
+        return TSK_ERR;
+    }
+
+    addr = tsk_getu32(a_fs->endian, wfsfs->sb.s_first_index_block);
+    inode_ind = 0;
+    max_inode = tsk_getu32(a_fs->endian, wfsfs->sb.s_last_index_valid);
+
+    for (inode_blk_ind = 0; inode_blk_ind < WFSFS_INODE_TABLE_SIZE(wfsfs); inode_blk_ind++) {
+        if (addr > a_fs->last_block) {
+            tsk_error_reset();
+            tsk_error_set_errno(TSK_ERR_FS_BLK_NUM);
+            tsk_error_set_errstr
+                ("wfsfs_dir_open_meta: Block too large for image: %" PRIu64, addr);
+            return 1;
+        }
+
+        cnt = tsk_fs_read(a_fs, addr * a_fs->block_size,
+                    (char *) inode_blk, a_fs->block_size);
+
+        if (cnt != a_fs->block_size) {
+            if (cnt >= 0) {
+                tsk_error_reset();
+                tsk_error_set_errno(TSK_ERR_FS_READ);
+            }
+            tsk_error_set_errstr2("wfsfs_dir_open_meta: Inode block %"
+                PRIu32 " at %" PRIu64, inode_blk_ind, addr);
+            return 1;
+        }
+
+        for (inode_ofs = 0; (inode_ofs < a_fs->block_size); 
+                   inode_ofs += WFSFS_INODE_SIZE) {
+            if ((inode_ind < a_fs->root_inum) &&
+                (inode_blk[inode_ofs+1] == 0x02 ||
+                inode_blk[inode_ofs+1] == 0x03)) {                    
+                    wfsfs_gen_dentry (inode_ind,
+                            (char *) &inode_blk[inode_ofs], fs_name);
+                    if (tsk_fs_dir_add(fs_dir, fs_name)) {
+                        tsk_fs_name_free(fs_name);
+                        return TSK_ERR;
+                    }
+            }
+
+            inode_ind += 1;
+        }
+        addr += 1;
+    }
+
+    /*
+    wfsfs_gen_dir_name(a_fs->root_inum, "/", fs_name);
+    fs_dir->fs_file->name = fs_name;
+    */
+
+    free(inode_blk);
+    tsk_fs_name_free(fs_name);
+    return TSK_OK;
+}
diff --git a/win32/PostgreSQL_CRT/win32/msvcr120.dll b/win32/PostgreSQL_CRT/win32/msvcr120.dll
deleted file mode 100644
index 8c36149a..00000000
Binary files a/win32/PostgreSQL_CRT/win32/msvcr120.dll and /dev/null differ
diff --git a/win32/PostgreSQL_CRT/win64/msvcr120.dll b/win32/PostgreSQL_CRT/win64/msvcr120.dll
deleted file mode 100755
index d711c922..00000000
Binary files a/win32/PostgreSQL_CRT/win64/msvcr120.dll and /dev/null differ
diff --git a/win32/libtsk/libtsk.vcxproj b/win32/libtsk/libtsk.vcxproj
index 555ec3bf..89254885 100755
--- a/win32/libtsk/libtsk.vcxproj
+++ b/win32/libtsk/libtsk.vcxproj
@@ -529,6 +529,8 @@ xcopy /E /Y "$(VCInstallDir)\redist\$(PlatformTarget)\Microsoft.VC140.CRT" "$(Ou
     <ClCompile Include="..\..\tsk\fs\fatfs.c" />
     <ClCompile Include="..\..\tsk\fs\fatfs_dent.cpp" />
     <ClCompile Include="..\..\tsk\fs\fatfs_meta.c" />
+	<ClCompile Include="..\..\tsk\fs\wfsfs.c" />
+    <ClCompile Include="..\..\tsk\fs\wfsfs_dent.c" />
     <ClCompile Include="..\..\tsk\fs\ffind_lib.c" />
     <ClCompile Include="..\..\tsk\fs\ffs.c" />
     <ClCompile Include="..\..\tsk\fs\ffs_dent.c" />
